/*
 * Copyright (C) 2015,2016 Christian Friedl <Mag.Christian.Friedl@gmail.com>
 *
 * This file is part of SteerGlance.
 *
 * SteerGlance is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

"use strict";

var q = require('q');
var sqlite3 = require('sqlite3').verbose();
// var sqlite3 = require('sqlite3');
var query = require('./Query.js');

function DB() {
    this._db = null;
}

DB.prototype.open = function(fileName) {
    this._db = new sqlite3.Database(fileName);
    return this;
};

DB.prototype.close = function() {
    this._db.close();
    return this;
};

DB.prototype.runSql = function(sqlString, params) {
    // console.log('sqlite_db.runSql', sqlString, params);
    const dfd = q.defer();
    console.log('sqlite_db_runSql: queryString', sqlString, 'parameters', params);
    this._db.run(sqlString, params, function(err) {
        console.log('sqlite_db_runSql: err', err);
        if ( err ) { dfd.reject(new Error(err)); }
        else { dfd.resolve(); }
    });
    console.log('runsql on', sqlString, 'has promise', dfd.promise);
    return dfd.promise;
};

DB.prototype.allSql = function(sqlString, params) {
    // console.log('sqlite_db.allSql', sqlString, params);
    const dfd = q.defer();
    console.log('sqlite_db_allSql: queryString', sqlString, 'parameters', params);
    this._db.all(sqlString, params, function(err, rows) {
        console.log('sqlite_db_allSql: err', err);
        if ( err ) { dfd.reject(new Error(err)); }
        else { dfd.resolve(rows); }
    });
    return dfd.promise;
};

DB.prototype.run = function(sqlQuery, callback) {
    var q = query.create(sqlQuery);
    var qs = q.getQueryString();
    var p = q.getParams();
    // console.log('sqlite_db.run: queryString: ', qs, p);
    return this.runSql(qs, p);
};


/**
 * sql query with params -> callback(err, row)
 */
DB.prototype.fetchRow = function(sqlQuery, callback) {
    var q = query.create(sqlQuery);
    var qs = q.getQueryString();
    var p = q.getParams();
    const dfd = q.defer();
    console.log('sqlite_db_fetchRow: queryString', qs, 'parameters', p);
    this._db.get(qs, p, function(err, row) {
        console.log('sqlite_db_fetchRow: err', err, ' result row is', row);
        if ( err ) { dfd.reject(new Error(err)); }
        else { dfd.resolve(row); }
    });
    return dfd.promise;
};

DB.prototype.fetchAll = function(sqlQuery, callback) {
    var q = query.create(sqlQuery);
    var qs = q.getQueryString();
    var p = q.getParams();
    console.log('sqlite_db_fetchAll: queryString', qs, 'parameters', p);
    this._db.all(qs, p, function(err, rows) {
        console.log('sqlite_db_fetchAll: err', err,' result rows is', rows);
        if ( err ) { dfd.reject(new Error(err)); }
        else { dfd.resolve(rows); }
    });
    return dfd.promise;
};

function db(fileName) {
    return new DB(fileName);
}

exports.DB = DB;
exports.db = db;
