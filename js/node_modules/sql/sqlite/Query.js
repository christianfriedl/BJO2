/*
 * Copyright (C) 2015-2017 Christian Friedl <Mag.Christian.Friedl@gmail.com>
 *
 * This file is part of SteerGlance.
 *
 * SteerGlance is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

"use strict";

const _ = require('lodash');
const q = require('q');

const BJOO = require('BJOObject.js');
const sql_Query = require('sql/Query.js');
const sql_DDL = require('sql/DDL.js');
const sql_Field = require('sql/Field.js');
const sql_ValueField = require('sql/ValueField.js');
const sql_Filter = require('sql/Filter.js');
const sql_Aggregate = require('sql/Aggregate.js');

function Query(sqlQuery) {
    BJOO.BJOObject.call(this);
    if ( arguments.length > 0 ) {
        /* @DEVELOPMENT { */
            if ( arguments.length !== 1 ) { throw new Error('Illegal argument length '  + arguments.length + ', should be ' + 1); }  
            if ( !(sqlQuery instanceof sql_Query.Query || sqlQuery instanceof sql_DDL.Query) ) { throw new Error('typecheck failed on sqlQuery'); }  
        /* @DEVELOMPENT } */
        this._sqlQuery = sqlQuery;

        this._queryString = this._getQueryString();
        this._params = this._getQueryParams();
    }
}

function create(sqlQuery) { if ( arguments.length > 0 ) { return new Query(sqlQuery); } else { return new Query(); } }

Query.prototype = new BJOO.BJOObject();
Query.prototype.constructor = Query;

Query.prototype._sqlQuery = null;

Query.prototype.getQueryString = function() {
    return this._queryString;
};

Query.prototype.getQueryParams = function() {
    return this._queryParams;
};

Query.prototype._getQueryString = function() {
    switch ( this._sqlQuery.getType() ) {
        case sql_Query.Type.select:
            return this._getSelectQueryString();
            break;
        case sql_Query.Type.insert:
            return this._getInsertQueryString();
            break;
        case sql_Query.Type.update:
            return this._getUpdateQueryString();
            break;
        case sql_Query.Type.delete:
            return this._getDeleteQueryString();
            break;
        case sql_DDL.Type.create:
            return this._getCreateQueryString();
            break;
        default:
            throw new Error('no such query type as ' + this._sqlQuery.getType());
            break;
    }
};

Query.prototype._getQueryParams = function() {
    switch ( this._sqlQuery.getType() ) {
        case sql_Query.Type.select:
            return this._getSelectQueryParams();
            break;
        case sql_Query.Type.insert:
            return this._getInsertQueryParams();
            break;
        case sql_Query.Type.update:
            return this._getUpdateQueryParams();
            break;
        case sql_Query.Type.delete:
            return this._getDeleteQueryParams();
            break;
        case sql_Query.Type.create:
            return [];
            break;
        default:
            throw new Error('no such query type as ' + this._sqlQuery.getType());
            break;
    }
};

Query.prototype._getInsertQueryString = function() {
    var table = this._sqlQuery.getTables()[0];
    var fields = this._sqlQuery.getFields();
    var sql = 'INSERT INTO ' + table.getName() + ' (';
    sql += _.map(fields, ( f ) => { return f.getName(); }).join(', '); // we do not use table.fields, because those values get cloned in the dao and are to be taken straight from the fields() in the query
    sql += ') VALUES (';
    sql += _.times(fields.length, _.constant('?')).join(', ');
    sql += ')';
    return sql;
};

Query.prototype._getInsertQueryParams = function() {
    var fields = this._sqlQuery.getFields();
    return this._createParamsFromFields(fields);
};

Query.prototype._getUpdateQueryString = function() {
    var table = this._sqlQuery.getTable();
    var sql = 'UPDATE ' + table.getName() + ' SET ';
    sql += _(this._sqlQuery.getFields()).map(( field ) => { return field.getName() + ' = ?'; }).join(', ');

    if ( this._sqlQuery.getFilters().length > 0 ) {
        sql += ' ' + this._getWhereClause();
    }

    return sql;
};

Query.prototype._getUpdateQueryParams = function() {
    let fields = this._sqlQuery.getFields().concat(this._getWhereClauseParams());
    return this._createParamsFromFields(fields);
};

/**
 * creates the query string for a delete query
 */
Query.prototype._getDeleteQueryString = function() {
    var table = this._sqlQuery.table();
    var sql = 'DELETE FROM ' + table.name();
    if ( this._sqlQuery.filters().length > 0 ) {
        sql += ' ' + this._getWhereClause();
    }

    return sql;
};

Query.prototype._getDeleteQueryParams = function() {
    let fields = this._getWhereClauseParams();
    return this._createParamsFromFields(fields);
};


Query.prototype._getSelectQueryString = function() {
    let sql = 'SELECT ';
    let fields = this._sqlQuery.getFields();
    let ffMap = _(fields).map(function(f) { 
        if ( f instanceof sql_Aggregate.Aggregate ) {
            let localSql = '';
            switch ( f.getType() ) {
                case sql_Aggregate.Type.sum:
                    localSql += 'SUM(' + f.getField().getFQName() + ')';
                    break;
                case sql_Aggregate.Type.count:
                    if ( f.getField() ) {
                        localSql += 'COUNT(' + f.field().getFQName() + ')';
                    } else {
                        localSql += 'COUNT(*)';
                    }
                    break;
                case sql_Aggregate.Type.min:
                    localSql += 'MIN(' + f.getField().getFQName() + ')';
                    break;
                case sql_Aggregate.Type.max:
                    localSql += 'MAX(' + f.getField().getFQName() + ')';
                    break;
                default:
                    throw 'no such aggregate: ' + f.type();
            }
            var alias = 'aggregate';
            if ( f.getAlias() !== null ) {
                alias = f.getAlias();
            } else if ( typeof(f.getField()) !== 'undefined' ) {
                alias = f.getField().getName();
            }
            localSql += ' AS ' + alias;

            return localSql;
        } else {
            return f.getFQName(); 
        }
    });
    sql += ffMap.join(', ') + ' FROM ';
    sql += _.map(this._sqlQuery.getTables(), ( t ) => { return t.getName(); }).join(', ');
    if ( this._sqlQuery.getFilters().length > 0 ) {
        sql += ' ';
        sql += this._getWhereClause();
    }

    sql += ' ' + this._orderByClause();
    sql += ' ' + this._limitOffsetClause();
    sql = sql.trim();
    return sql;
};

Query.prototype._getSelectQueryParams = function() {
    let fields = this._getWhereClauseParams();
    return this._createParamsFromFields(fields);
};


Query.prototype._isField = function(fieldOrValue) {
    return ( fieldOrValue instanceof sql_ValueField.ValueField );
};

Query.prototype._getWhereClause = function() {
    let fields = [];
    let sql = 'WHERE ';
    sql += _.map(this._sqlQuery.getFilters(), ( c ) => { 
        var fieldOrValue = c.getCompareTo();
        var what = null;
        if ( this._isField(fieldOrValue) ) {
            what = fieldOrValue.getFQName();
        } else {
            what = '?';
        }
        return c.getField().getFQName() + ' ' + this.getOpString(c.getOp()) + ' ' + what;
    }).join(' AND ');
    return sql;
};

Query.prototype._getWhereClauseParams = function() {
    return _.map(_.filter(this._sqlQuery.getFilters(), ( filter ) => { 
        return !(this._isField(filter.getCompareTo()));
    }), ( filter ) => {
        return { getValue: () => { return q(filter.getCompareTo()); } }; // phew, we create a spontaneous object that will just have a getValue() for this...
    });
};

Query.prototype._limitOffsetClause = function() {
    var offset = this._sqlQuery.offset();
    if ( this._sqlQuery.limit() !== null )  {
        if ( offset === null ) {
            offset = 0;
        }
        return 'LIMIT ' + + this._sqlQuery.limit() + ' OFFSET ' + offset + ' ';
    } else if ( this._sqlQuery.offset() !== null ) {
        throw new Exception('offset without limit is illegal.');
    } else {
        return ' ';
    }
};

Query.prototype.getOpString = function(op) {
    switch ( op ) {
        case sql_Filter.Op.eq:
            return '=';
        default:
            throw new Error('TODO implement getOpString other than eq!!!');
    }
};

Query.prototype._orderByClause = function() {
    if ( this._sqlQuery.getOrderBy() )  {
        return 'ORDER BY ' + _(this._sqlQuery.getOrderBy().getFields()).reduce(function(memo, o) { return (memo === '' ? '' : ', ') + this._orderByStuff(o); }.bind(this), '') + ' ';
    } else {
        return ' ';
    }
};

/**
 * ahem, TODO, the name is awful
 */
Query.prototype._orderByStuff = function(orderBy) {
    return orderBy.getField().getName() + ' ' + orderBy.getDirection();
};

Query.prototype._getCreateQueryString = function() {
    var table = this._sqlQuery.table();
    var sql = 'CREATE TABLE ' + table.name() + ' (';
    sql += _.map(table.fields(), function(f) { return this._createFieldString(f); }.bind(this)).join(', ');
    sql += ')';
    return sql;
};

Query.prototype._createFieldString = function(field) {
    var sql = field.name() + ' ' + this._createFieldTypeString(field);
    return sql;
};

Query.prototype._createFieldTypeString = function(f) {
    switch ( f.dataType() ) {
        case sql_Field.DataType.int:
            return 'INT';
        case sql_Field.DataType.string:
            return 'TEXT';
        default:
            throw 'no such field type: ' + f.type();
    }
};

/** 
 * NOTE: _params now is a promise for all values
 */
Query.prototype.getParams = function() { 
    return this._params;
};

Query.prototype._createParamsFromFields = function(fields) {
    return q.all( _.map(fields, ( field ) => { return field.getValue(); }) );
};

exports.Query = Query;
exports.create = create;
