"use strict";

var m_bjoo = require('BJOObject.js');
var m_sql_query = require('sql/query.js');
var m_sql_ddl = require('sql/ddl.js');
var m_sql_field = require('sql/field.js');
var m_sql_condition = require('sql/condition.js');
var m_sql_aggregate = require('sql/aggregate.js');
var _ = require('underscore');

function Query(p_serverQuery) {
    m_bjoo.BJOObject.call(this);
    if ( arguments.length > 0 ) {
        /* @DEVELOPMENT { */
            if ( arguments.length !== 1 ) { throw new Error('Illegal argument length '  + arguments.length + ', should be ' + 1); }  
            if ( !(p_serverQuery instanceof m_sql_query.Query || p_serverQuery instanceof m_sql_ddl.Query) ) { throw new Error('typecheck failed on p_serverQuery'); }  
        /* @DEVELOMPENT } */
        this._serverQuery = p_serverQuery;
        this._params = [];
    }
    this._className = 'sqlite.Query';
}

Query.prototype = new m_bjoo.BJOObject();
Query.prototype.constructor = Query;

Query.prototype.queryString = function() {
    this._params = []; // !!!!! this is not very nice, the query string methods are not repeatable!
    switch ( this._serverQuery.type() ) {
        case m_sql_query.Type.select:
            return this._selectQueryString();
            break;
        case m_sql_query.Type.insert:
            return this._insertQueryString();
            break;
        case m_sql_query.Type.update:
            return this._updateQueryString();
            break;
        case m_sql_ddl.Type.create:
            return this._createQueryString();
            break;
        default:
            throw 'no such query type';
            break;
    }
};

Query.prototype._insertQueryString = function() {
    var table = this._serverQuery.tables()[0];
    var fields = this._serverQuery.fields();
    var sql = 'INSERT INTO ' + table.name() + ' (';
    sql += _(fields).invoke('name').join(', '); // we do not use table.fields, because those values get cloned in the dao and are to be taken straight from the fields() in the query
    sql += ') VALUES (';
    sql += _(fields).map(function(field) { this._params.push(field.value()); return '?'; }.bind(this)).join(', ');
    sql += ')';
    return sql;
};

Query.prototype._updateQueryString = function() {
    var table = this._serverQuery.table();
    var sql = 'UPDATE ' + table.name() + ' SET ';
    sql += _(this._serverQuery.fields()).map(function(field) { this._params.push(field.value()); return field.name() + ' = ?'; }.bind(this)).join(', ');

    if ( this._serverQuery.conditions().length > 0 ) {
        sql += ' ' + this._whereClause();
    }

    return sql;
};

Query.prototype._deleteQueryString = function() {
    var table = this._serverQuery.table();
    var sql = 'DELETE FROM ' + table.name();
    if ( this._serverQuery.conditions().length > 0 ) {
        sql += ' ' + this._whereClause();
    }

    return sql;
};

Query.prototype._selectQueryString = function() {
    console.log('#### serverQuery in _selectQueryString', this._serverQuery);
    var sql = 'SELECT ';
    var ff = this._serverQuery.fields();
    var ffMap = _(ff).map(function(f) { 
        if ( f instanceof m_sql_aggregate.Aggregate ) {
            console.log('_selectQueryString aggregate field', f);
            switch ( f.type() ) {
                case m_sql_aggregate.Type.sum:
                    sql += 'SUM(' + f.field().fQName() + ')';
                    break;
                case m_sql_aggregate.Type.count:
                    if ( f.field() ) {
                        sql += 'COUNT(' + f.field().fQName() + ')';
                    } else {
                        sql += 'COUNT(*)';
                    }
                    break;
                default:
                    throw 'no such aggregate: ' + ff.type();
            }
            var alias = 'aggregate';
            if ( f.alias() !== null ) {
                alias = f.alias();
            } else if ( typeof(f.field()) !== 'undefined' ) {
                alias = f.field().name();
            }
            sql += ' AS ' + alias;
        } else {
            return f.fQName(); 
        }
    });
    sql += ffMap.join(', ') + ' FROM ';
    sql += _(this._serverQuery.tables()).invoke('name').join(', ');
    if ( this._serverQuery.conditions().length > 0 ) {
        sql += ' ';
        sql += this._whereClause(this._serverQuery);
    }
    console.log('_selectQueryString is', sql);
    return sql;
};

Query.prototype._fieldRefOrValue = function(fieldOrValue) {
    if ( fieldOrValue instanceof m_sql_field.Field ) {
        return fieldOrValue.name();
    } else {
        return "'" + fieldOrValue + "'";
    }
};

Query.prototype._isField = function(fieldOrValue) {
    return ( typeof(fieldOrValue._className) !== 'undefined' && (fieldOrValue.className() === 'sql.LookupField' || fieldOrValue.className() === 'sql.Field' || fieldOrValue.className() === 'sql.CalcField') ); 
};

Query.prototype._whereClause = function() {
    var sql = 'WHERE ';
    sql += _.map(
        this._serverQuery.conditions(), function(c) { 
            console.log('whereclause conditions c', c);
            var fieldOrValue = c.compareTo();
            var what = null;
            if ( this._isField(fieldOrValue) ) {
                what = fieldOrValue.fQName();
            } else {
                what = '?';
                this._params.push(fieldOrValue);
            }
            return c.field().fQName() + ' ' + this._opString(c.op()) + ' ' + what;
        }.bind(this)).join(' AND ');
    return sql;
};

Query.prototype._opString = function(op) {
    switch ( op ) {
        case m_sql_condition.Op.eq:
            return '=';
        default:
            console.log('unimplemented', op);
            throw new Error('TODO implement _opString!!!');
    }
};

Query.prototype._createQueryString = function() {
    var table = this._serverQuery.table();
    var sql = 'CREATE TABLE ' + table.name() + ' (';
    sql += _.map(table.fields(), function(f) { return this._createFieldString(f); }.bind(this)).join(', ');
    sql += ')';
    return sql;
};

Query.prototype._createFieldString = function(field) {
    var sql = field.name() + ' ' + this._createFieldTypeString(field);
    return sql;
};

Query.prototype._createFieldTypeString = function(f) {
    switch ( f.dataType() ) {
        case m_sql_field.DataType.int:
            return 'INT';
        case m_sql_field.DataType.string:
            return 'TEXT';
        default:
            throw 'no such field type: ' + f.type();
    }
};

Query.prototype.params = function() {
    if ( arguments.length > 0 ) {
        this._params = Array.prototype.slice.call(arguments);
        return this;
    }
    return this._params;
};

function query(serverQuery) { return new Query(serverQuery); }

exports.Query = Query;
exports.query = query;
