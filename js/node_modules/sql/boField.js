/*
 * a boField will describe a field whose object is, itself, a business object.
 * it will be linked to a lookupField (or any other field that has itself a fieldLink)
 * and will retrieve its value by loading (or, later on, caching) the bo
 */
"use strict";

var _ = require('underscore');
var util = require('util');
var m_util = require('util.js');
var m_bjoo = require('BJOObject.js');
var m_sql_field = require('sql/field.js');
var m_sql_db = require('sql/db.js');
var m_bo = require('bo/BO.js');

function BoField(/*String*/ name, /* Object */ value, /*[String]*/ label, /* m_sql_db.DB */ db, /* Function */ constructor, /* m_sql_field.Field */ idField) {
    if ( arguments.length > 0 ) {
        /* @DEVELOPMENT { */
            if ( arguments.length !== 6 ) { throw new Error('Illegal argument length '  + arguments.length + ', should be ' + 6); }
            var PARAM = name; if ( !(m_util.isString(PARAM)) ) { throw new Error('typecheck failed on ' + PARAM + ': ' + PARAM); }
            var PARAM = label; if ( !(m_util.isString(PARAM)) ) { throw new Error('typecheck failed on label: ' + PARAM); }
            if ( !(db instanceof m_sql_db.DB) ) { throw new Error('Typecheck failure: db should be of class m_sql_db.DB: ' + db); }
            if ( !(constructor instanceof Function) ) { throw new Error('Typecheck failure: constructor should be of class Function: ' + constructor); }
            if ( !(idField instanceof m_sql_field.Field || idField === null) ) { throw new Error('Typecheck failure: idField should be of class m_sql_field.Field: ' + idField); }
        /* @DEVELOMPENT } */
        m_sql_field.Field.call(this, name, m_sql_field.DataType.bo, value, label); 

        this._db = db; // TODO blargh fields should never have to know about the db...
        this._constructor = constructor;
        this._idField = idField;
        this._isDatabaseField = false;
    } else {
        m_sql_field.Field.call(this);
    }
}

function boField(/*String*/ name, /* ? */ value, /*[String]*/ label, /* m_sql_db.DB */ db, /* Function */ constructor, /* m_sql_field.Field */ idField) {
    if ( arguments.length > 0 ) {
        /* @DEVELOPMENT { */
            var PARAM = name; if ( !(m_util.isString(PARAM)) ) { throw new Error('typecheck failed on ' + PARAM + ': ' + PARAM); }
            var PARAM = label; if ( !(m_util.isString(PARAM)) ) { throw new Error('typecheck failed on label: ' + PARAM); }
            var PARAM = constructor; if ( !(PARAM instanceof Function) ) { throw new Error('typecheck failed on constructor: ' + PARAM); }
            if ( !(db instanceof m_sql_db.DB) ) { throw new Error('Typecheck failure: db should be of class m_sql_db.DB: ' + db); }
            if ( !(idField instanceof m_sql_field.Field || idField === null) ) { throw new Error('Typecheck failure: idField should be of class m_sql_field.Field: ' + idField); }
            if ( arguments.length !== 6 ) { throw new Error('Illegal argument length '  + arguments.length + ', should be ' + 5); }
        /* @DEVELOMPENT } */

        return new BoField(name, value, label, db, constructor, idField);
    } else {
        return new BoField();
    }
}

BoField.prototype = new m_sql_field.Field();
BoField.prototype.constructor = BoField;

BoField.prototype.clone = function() {
    var f = new BoField(this._name, this._value, this._label, this._db, this._constructor, this._idField);
    f._id = this._id; // one exception to the use-the-setter-luke rule
    return f;
};

/*
 * we need to make sure that our id field is actually the one in our bo, not just the one from the table
 * - this is to avoid having to set our id field after the fact of our construction by way of function idField(field)
 */
/* this */ BoField.prototype.onAfterAddToBo = function(/* m_bo.BO */ bo) {
    /* @DEVELOPMENT { */
        if ( arguments.length !== 1 ) { throw new Error('Illegal argument length '  + arguments.length + ', should be ' + 1); }
        /// TODO wtf why is bo not an instance of BO???
        // if ( !(bo instanceof m_bo.BO) ) { throw new Error('Typecheck failure: bo should be of class m_bo.BO: ' + util.inspect(bo)); }
    /* @DEVELOMPENT } */

    var idField = bo.field(this._idField.name());
    if ( this._idField !== idField ) { // it has to be the exact same object
        this._idField = idField;
    }
    return this; // void
}


BoField.prototype.loadBo = function(/* m_sql_db.DB */ db, callback) {
    this._bo = this._constructor.call({}, db);
    return this._bo.loadById(this._idField.value(), callback);
};


/*
 * setting boField's value means that we receive a bo and store it, just
 * like Field's default behaviour - but as a side-effect, we store the id in our id field
 *
 * getting the value means creating the bo from the id field, 
 * and returning it -- optimization: cache it if the id has not changed(?)
 */
BoField.prototype.value = function(bo) {

    if ( typeof(bo) !== 'undefined' ) {
        /* @DEVELOPMENT { */ 
            // TODO what the.... this does not check out!!!
            // if ( !(bo instanceof m_bo.BO) ) { throw new Error('Typecheck failure: bo should be of class m_bo.BO: ' + bo); }
        /* @DEVELOMPENT } */
        this._bo = bo;
        this._idField.value(bo.id());
        return this;
    }

    return this._bo;
};

BoField.prototype.idField = function(idField) {
    if ( typeof(idField) !== 'undefined' ) {
        this._idField = idField;
        return this;
    }
    return this._idField;
};

exports.BoField = BoField;
exports.boField = boField;
