/*
 * Copyright (C) 2015,2016 Christian Friedl <Mag.Christian.Friedl@gmail.com>
 *
 * This file is part of SteerGlance.
 *
 * SteerGlance is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

"use strict";

var _ = require('underscore');
var m_sql_conditionSet = require('sql/ConditionSet.js');

/*
 * insert into t ( fields... ) values ( values... )
 * update t set f=v, f=v where f=v
 * delete from t where f=v
 *
 * select f, f from t where f=v
 *
 */

var bjoo = require('BJOObject.js');

var Type = { select: 'select', update: 'update', 'delete': 'delete', insert: 'insert' };

function Query() {
    this._type = undefined;
    this._fields = []; // actually, field, or value, or aggregate...
    this._tables = [];
    this._filters = [];
    this._limit = null;
    this._offset = null;
    this._orderBy = null;
}

Query.prototype = new bjoo.BJOObject();
Query.prototype.constructor = Query;

/******************getters/setters**************/

Query.prototype.getType = function() {
    return this._type;
};

Query.prototype.getTables = function() {
    return this._tables;
};

Query.prototype.setTables = function(tables) {
    /* @DEVELOPMENT */ if (!(tables instanceof Array)) { throw new Error('tables must be an array'); }
    this._tables = tables;
    return this;
};

Query.prototype.getFields = function() {
    return this._fields;
};

/*
 * if the fields were already set by table(), setting fields will overwrite it
 */
Query.prototype.setFields = function(fields) {
    /* @DEVELOPMENT */if (!(fields instanceof Array)) { throw new Error('fields must be an array'); }
    this._fields = fields;
    return this;
};

Query.prototype.getFilters = function(filters) {
    return this._filters;
};

Query.prototype.setFilters = function(filters) {
    /* @DEVELOPMENT */if (!(filters instanceof Array)) {throw new Error('filters must be an array'); }
    this._filters = filters;
    return this;
};

Query.prototype.setGroupBys = function(groupBys) {
    /* @DEVELOPMENT */if (!(groupBys instanceof Array)) {throw new Error('filters must be an array'); }
    this._groupBys = groupBys;
    return this;
};

Query.prototype.getGroupBys = function(groupBys) {
    return this._groupBys;
};

/***********************************************/

Query.prototype.groupBy = function(groupBy) {
    this._groupBys.push(groupBy);
    return this;
};

Query.prototype.select = function() {
    this._type = Type.select;
    this._fields = Array.prototype.slice.call(arguments);
    return this;
};

Query.prototype.update = function() {
    this._type = Type.update;
    this._fields = Array.prototype.slice.call(arguments);
    return this;
};

Query.prototype.insert = function() {
    this._type = Type.insert;
    this._fields = Array.prototype.slice.call(arguments);
    return this;
};

Query.prototype.delete = function() {
    this._type = Type.delete;
    return this;
};

Query.prototype.from = function(tables) {
    this._tables = Array.prototype.slice.call(arguments);
    return this;
};

Query.prototype.into = function(table) {
    this._tables = [ table ];
    return this;
};

Query.prototype.getTable = function() {
    return this._tables[0];
};
Query.prototype.setTable = function(table) {
    this._tables = [ table ];
    return this;
};

Query.prototype.limit = function(limit) {
    if ( typeof(limit) !== 'undefined' ) {
        this._limit = limit;
        return this;
    }
    return this._limit;
};

Query.prototype.offset = function(offset) {
    if ( typeof(offset) !== 'undefined' ) {
        this._offset = offset;
        return this;
    }
    return this._offset;
};

Query.prototype.orderBy = function(orderBy) {
    if ( typeof(orderBy) !== 'undefined' ) {
        this._orderBy = orderBy;
        return this;
    }
    return this._orderBy;
};

/**
 * where(filter, filter...)
 * --- will add to current filters (which are ANDed... TODO we don't have OR yet)
 */
Query.prototype.where = function() {
    /* @DEVELOPMENT */if (arguments.length === 1 && arguments[0] instanceof Array) throw new Error('arguments to query.where() are not supposed to be an array');
    this._filters = _(this._filters).union(Array.prototype.slice.call(arguments));
    return this;
};

/**
 * conditions are the query metadata
 * and will be represented in the query by their parts
 */
/* this/object */ Query.prototype.conditions = function(/* optional m_sql_conditionSet */ conditions) {
    if ( typeof(conditions) !== 'undefined' ) {
        if ( conditions.filters().length > 0 ) {
            this.filters(conditions.filters());
        }

        if ( typeof(conditions.limit()) !== 'undefined' ) {
            this.limit(conditions.limit());
        }

        if ( typeof(conditions.offset()) !== 'undefined' ) {
            this.offset(conditions.offset());
        }

        if ( typeof(conditions.orderBy()) !== 'undefined' ) {
            this.orderBy(conditions.orderBy());
        }
        return this;
    }
    return m_sql_conditionSet.conditionSet(this._filters, this._limit, this._offset, this._orderBy);
};

function select() {
    return Query.prototype.select.apply(new Query(), Array.prototype.slice.call(arguments));
}

function insert() {
    return Query.prototype.insert.apply(new Query(), Array.prototype.slice.call(arguments));
}

function update() {
    return Query.prototype.update.apply(new Query(), Array.prototype.slice.call(arguments));
}

function remove() {
    return Query.prototype.delete.apply(new Query(), Array.prototype.slice.call(arguments));
}

exports.Type = Type;
exports.Query = Query;
exports.select = select;
exports.insert = insert;
exports.update = update;
exports.delete = remove;


