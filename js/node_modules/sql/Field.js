/*
 * Copyright (C) 2015-2017 Christian Friedl <Mag.Christian.Friedl@gmail.com>
 *
 * This file is part of SteerGlance.
 *
 * SteerGlance is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

"use strict";

const _ = require('lodash');
const q = require('q');
const Util = require('Util.js');
const bjoo = require('BJOObject.js');
// var m_sql_fieldLink = require('sql/FieldLink.js');
const Errors = require('Errors.js');

const DataType = { int: 'int', string: 'string', };

function ValidationException(field, message) {
   this._field = field;
   this._message = message;
}

function validationException(field, message) { return new ValidationException(field, message); }


ValidationException.prototype = new bjoo.BJOObject();
ValidationException.prototype.constructor = ValidationException;

/**
 * @class sql.Field
 * @extends BJOObject
 * @constructor
 */
function Field(/*String*/ name, /*m_sql_field.DataType*/ dataType, /*[String]*/ label) {
    bjoo.BJOObject.call(this);
    if ( arguments.length > 0 ) {
        if ( !(Util.isString(name)) ) { throw new Error('Typecheck failure: name should be of type String: ' + name); }
        if ( !(Util.isString(dataType)) ) { throw new Error('Typecheck failure: dataType should be of type String: ' + dataType); }

        this._id = Util.guid();   // this is NOT the guid. it is unique to what this field represents, not the object itself. 
                                    // in case of clone(), this id will be copied over to the new object!
                                    // TODO 201610 does this still hold?
        this._name = name;
        this._dataType = dataType;
        this._table = null;
        if ( typeof(label) !== 'undefined' ) {
            this._label = label;
        } else {
            this._label = name;
        }
        this._links = {};
        this._seq = undefined; // seq nr, e.g. in a table
        this._isEditable = true; 
        this._isRequired = false; 
        this._isPersistent = false; // the better default, since really only ValueField is persistent
    }
}

function create(name, dataType, label) { if ( arguments.length > 1 ) { return new Field(name, dataType, label); } else { return new Field(); } }

Field.prototype = new bjoo.BJOObject();
Field.prototype.constructor = Field;
/**
 * Is this Field reflected directly in the DB?
 * @property {Boolean} isPersistent 
 */
Field.prototype.isPersistent = true;
/**
 * Can this Field be edited by the user?
 * @property {Boolean} isEditable 
 */
Field.prototype.isEditable = true;
/**
 * Does this Field have to be set before saving?
 * @property {Boolean} isRequired 
 */
Field.prototype.isRequired = true;

exports.Field = Field;
exports.create = create;
exports.DataType = DataType;
exports.ValidationException = ValidationException;
exports.validationException = validationException;

/**
 * @method clone
 * @return {sql.Field}
 */
Field.prototype.clone = function() {
    var f = new Field(this._name, this._dataType, this._value);
    f.setTable(this._table);
    f.setIsEditable(this._isEditable);
    f.setIsRequired(this._isRequired);
    f.setIsPersistent(this._isPersistent);
    f.setValidation(this._validation);
    f._id = this._id; // one exception to the use-the-setter-luke rule
    f.setValidation(this._validation);
    return f;
};

/* String */ Field.prototype.getId = function(/* void */) {
    return this._id;
};


Field.prototype.getTable = function(table) {
    return this._table;
};

Field.prototype.setTable = function(table) {
    const sql_Table = require('sql/Table.js');
    /* @DEVELOMPENT { */ if (!(table instanceof sql_Table.Table)) { throw new Errors.ParameterError(table, 'table', 'sql_Table.Table'); } /* @DEVELOPMENT } */
    this._table = table;
    return this;
};

Field.prototype.getSeq = function(seq) {
    return this._seq;
};

Field.prototype.setSeq = function(seq) {
    this._seq = seq;
    return this;
};

Field.prototype.getName = function(name) {
    return this._name;
};

Field.prototype.setName = function(name) {
	    this._name = name;
        return this;
};

Field.prototype.getDataType = function() {
    return this._dataType;
};
Field.prototype.setDataType = function(dataType) {
    this._dataType = dataType;
    return this;
};


Field.prototype.getIsEditable = function() {
    return this._isEditable;
};

Field.prototype.setIsEditable = function(isEditable) {
    this._isEditable = isEditable;
    return this;
};

Field.prototype.getIsRequired = function() {
    return this._isRequired;
};

Field.prototype.setIsRequired = function(isRequired) {
    this._isRequired = isRequired;
    return this;
};

Field.prototype.getIsPersistent = function() {
    return this._isPersistent;
};

Field.prototype.setIsPersistent = function(isPersistent) {
    this._isPersistent = isPersistent;
    return this;
};

Field.prototype.getIdentifierName = function() {
    return this._name; // TODO!!!
};

Field.prototype.getFQName = function() { // TODO hmmmm.... reflect on whether this should be in Table
    if ( this._table === null ) {
        return this.getName();
    } else {
        return this._table.getName() + '.' + this.getName(); // TODO, at some point we'll need a unique table identifier
    }
};

Field.prototype.getAccessorName = function() {
    return this.identifierName();
};

Field.prototype.getterName = function() {
    var iName = this.identifierName();
    return 'get' + iName.substr(0, 1).toUpperCase() + iName.substr(1);
};

Field.prototype.setterName = function() {
    var iName = this.identifierName();
    return 'set' + iName.substr(0, 1).toUpperCase() + iName.substr(1);
};

Field.prototype.getLabel = function() {
    return this._label;
};
Field.prototype.setLabel = function(label) {
	    this._label = label;
        return this;
};

/*
 * getter/setter 
 * field links for this field
 */
/*[]/this*/Field.prototype.links = function(links) {
    if ( typeof(links) !== 'undefined' ) {
        this._links = links;
        return this;
    }
    return this._links;
};

// return non-circular object, so it can be jsonified and sent to the webz
// TODO name is a bit dodgy
// @pure
/* Promise(Object) */Field.prototype.toJson = function() {
    return q({ 
        className: this.constructor.name, 
        name: this._name, 
        dataType: this._dataType, 
        label: this._label,
        seq: this._seq,
        isEditable: this._isEditable,
        isRequired: this._isRequired,
        links: this._linksToJson()
    });
};

/* validate will not return a value, but rather throw a ValidationException on error */
/**
 * @param Object value
 * @param Object ctx user-provided object
 */
/*Promise*/ Field.prototype.validate = /*void*/function(/* Object */ value, /* Object*/ ctx) {
    // if no validation is set, we will assume all is good
    if ( this._validation !== undefined ) {
        try {
            this._validation.bind(this)(value, ctx); // ignore return value so user need not return this
        } catch(e) {
            const deferred = q.defer();
            deferred.reject(e);
            return deferred.promise;
        }
    }
    return q(this).promise;
};

/* function(value, [ctx]) */ Field.prototype.getValidation = function() {
    return this._validation;
};

Field.prototype.setValidation = function(/* function(value, [ctx]) */ validation) {
    this._validation = validation;
    return this;
};
