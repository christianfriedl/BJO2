/*
 * Copyright (C) 2015-2017 Christian Friedl <Mag.Christian.Friedl@gmail.com>
 *
 * This file is part of SteerGlance.
 *
 * SteerGlance is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

"use strict";

// deps are in an object, so DI can replace these
const deps = { 
    _: require('lodash'),
    bjoo: require('BJOObject'),
    http: require('http'), 
    anyBody: require('body/any'),
    jsonBody: require('body/json'),
    router: require('web/server/router.js'),
};


/**
 * The Web Server Class
 * @class web.server.Server
 * @constructor
 * @param {Object} config
 */
function Server(config) {
    deps.bjoo.BJOObject.call(this);
    if ( arguments.length > 0 ) {
        this._config = config;
    }
}

/**
 * the external constructor
 * @param {Object} config
 */
function create(config) {
    return new Server(config);
}

Server.prototype = deps.bjoo.create();
exports.Server = Server;
exports.create = create;
exports.deps = deps;

/**
 * run the server, never terminate
 * @method run
 */
Server.prototype.run = function() {
    deps.http.createServer((request, response) => {
        if (request.url === '/favicon.ico') return; /////// i don't want this in the log for now (TODO remove it)
        if ( request.method === 'POST' ) {
            deps.jsonBody(request, response, (err, body) => {
                if ( err ) {
                    throw err;
                }
                request.body = body;
                this._handleRequest(request, response);
            });
        } else {
            this._handleRequest(request, response);
        }

    }).listen(this._config.web.server.port);
};

/**
 * handle one request
 * @private
 * @method _handleRequest
 * @param {HttpRequest} request
 * @param {HttpResponse} response
 */
Server.prototype._handleRequest = function(httpRequest, httpResponse) {
    const routeDesc = deps.router.route(httpRequest.url);

    const internalRequest = { 
        controllerName: routeDesc.controllerName, actionName: routeDesc.actionName, 
        url: httpRequest.url, query: routeDesc.query,
        body: httpRequest.body
    };

    const internalResponse = { 
        returnCode: 200, 
        contentType: 'text/html', 
        text: null, 
    };

    try {
        const method = this._getActionMethod(routeDesc);
        method(internalRequest, internalResponse).done((internalResponse) => {
            const returnMessage = ( internalResponse.returnCode === 200 ? 'ok' : 'failed' );
            const defaultHeaders = { 'Content-Type': internalResponse.contentType };
            const headers = deps._.merge(defaultHeaders, internalResponse.headers);
            httpResponse.writeHead(internalResponse.returnCode, returnMessage, headers);
            httpResponse.write(this._getResponseText(internalResponse));
            httpResponse.end();
        });
    } catch (e) {
        console.error('Handling controller-finding error', e);
        this._callErrorAction(internalRequest, internalResponse, e.message).done((resp) => {
            httpResponse.writeHead(resp.returnCode, {'Content-Type': resp.contentType});
            httpResponse.write(resp.text);
            httpResponse.end();
        });
    }
};

/**
 * create the response text from the response object
 *
 * @private
 * @param {Object} response
 * @return {String}
 */
Server.prototype._getResponseText = function(response) {
    switch ( response.contentType ) {
        case 'text/json':
            return JSON.stringify(response.json);
        case 'text/html':
        default:
            return response.text;
    }
};

/**
 * display the error page
 * - will find the error controller and action, and receive the text from it
 * @method _callErrorAction
 * @private
 * @param {Object} req the internal request
 * @param {Object} resp the internal response
 * @return {Object} the amended response
 */
Server.prototype._callErrorAction = function(req, resp, message) {
    const dir = this._getControllerDir('ErrorController.js');
    if ( !dir ) {
        throw new Error('while handling error "' + e.message + '", could not find directory for Error Controller');
    }
    const method = this._getControllerMethod(dir, 'ErrorController.js', 'error');
    if ( !method ) {
        throw new Error('while handling error "' + e.message + '", could not find error action method in Error Controller');
    }
    req.error = message;
    return method(req, resp);
};

/**
 * from the route description, this method will find the controller and the action method inside it
 * @private
 * @method _getActionMethod
 * @param routeDesc
 */
Server.prototype._getActionMethod = function(routeDesc) {
    // TODO can we find a more generic way to find the controller?
    const controllerFileName = this._getControllerFileName(routeDesc.controllerName);
    const controllerDir = this._getControllerDir(controllerFileName);

    if ( !controllerDir ) {
        throw new Error('dir for controller file ' + controllerFileName + ' not found');
    }

    const method = this._getControllerMethod(controllerDir, controllerFileName, routeDesc.actionName);

    if ( method === undefined ) {
        throw new Error('method not found: ' + routeDesc.actionName + ' in controller ' + routeDesc.controllerName);
    }
    return method;
};

/**
 * resolve the controller module, then resolve the method inside it
 * @method _getControllerMethod
 * @private
 * @param {String} dir the resolved directory where the controller module file resides
 * @param {String} fileName name of controller file
 * @param {String} actionName name of controller action
 */
Server.prototype._getControllerMethod = function(dir, fileName, actionName) {
    const controllerModule = require(dir + '/' + fileName);
    const controllerObject = controllerModule.create(this._config);
    return controllerObject[this._getActionMethodName(actionName)].bind(controllerObject);
};
        
/**
 * by running through the possible controller directories, find the controller method
 * @method _getControllerDir
 * @private
 * @param {String} controllerFileName
 * @return {String|Boolean} dir if we found it, otherwise false
 */
Server.prototype._getControllerDir = function(controllerFileName) {
    return deps._.find(this._config.web.server.controllerDirs, ( dir ) => {
        const controllerPath = dir + '/' + controllerFileName;
        try { // TODO this is ugly and brittle code, can we somehow test for the existence of a required file without using require()?
            require(controllerPath);
            return true;
        } catch (e) {
            if ( e.message !== "Cannot find module '" + controllerPath + "'" ) {
                console.error('Error while resolving controller ' + controllerFileName, e);
                throw e;
            }
            return undefined;
        }
    });
}
/**
 * @private
 */
Server.prototype._getControllerFileName = function(controllerName) {
    return this._getControllerClassName(controllerName) + '.js';
};

/**
 * @private
 */
Server.prototype._getControllerClassName = function(controllerName) {
    return deps._.capitalize(controllerName) + 'Controller';
};

/**
 * @private
 */
Server.prototype._getActionMethodName = function(actionName) {
    return actionName + 'Action';
};
