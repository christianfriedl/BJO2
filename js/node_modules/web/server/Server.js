/*
 * Copyright (C) 2015,2016 Christian Friedl <Mag.Christian.Friedl@gmail.com>
 *
 * This file is part of SteerGlance.
 *
 * SteerGlance is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

"use strict";

// deps are in an object, so DI can replace these
const deps = { 
    _: require('lodash'),
    bjoo: require('BJOObject'),
    http: require('http'), 
    anyBody: require('body/any'),
    jsonBody: require('body/json'),
    router: require('web/server/router.js'),
};


/**
 * @class web.server.Server
 * @constructor
 * @param {Object} config
 */
function Server(config) {
    deps.bjoo.BJOObject.call(this);
    if ( arguments.length > 0 ) {
        this._config = config;
    }
}

function create(config) {
    return new Server(config);
}

Server.prototype = deps.bjoo.create();
exports.Server = Server;
exports.create = create;
exports.deps = deps;

Server.prototype.run = function() {
    deps.http.createServer((request, response) => {
        if (request.url === '/favicon.ico') return; /////// i don't want this in the log for now (TODO remove it)
        if ( request.method === 'POST' ) {
            deps.jsonBody(request, response, (err, body) => {
                if ( err ) {
                    throw err;
                }
                request.body = body;
                this._handleRequest(request, response);
            });
        } else {
            this._handleRequest(request, response);
        }

    }).listen(this._config.web.server.port);
};

Server.prototype._handleRequest = function(request, response) {
    const routeDesc = deps.router.route(request.url);
    this._serveRequest(request, routeDesc, response);
    // TODO report exception/ route error to client somehow...
};

Server.prototype._serveRequest = function(origRequest, routeDesc, httpResponse) {
    const internalRequest = { 
        controllerName: routeDesc.controllerName, actionName: routeDesc.actionName, 
        url: origRequest.url, query: routeDesc.query,
        body: origRequest.body
    };

    const internalResponse = { 
        returnCode: 200, 
        contentType: 'text/html', 
        text: null, 
    };

    try {
        const actionMethod = this._getActionMethod(routeDesc);
        actionMethod(internalRequest, internalResponse).done((internalResponse) => {
            httpResponse.writeHead(internalResponse.returnCode, {'Content-Type': internalResponse.contentType});
            httpResponse.write(internalResponse.text);
            httpResponse.end();
        });
    } catch (e) {
        console.error('Handling controller-finding error', e);
        this._callErrorAction(internalRequest, internalResponse, httpResponse, e.message);
    }
};

Server.prototype._callErrorAction = function(req, resp, httpResponse, message) {
    const dir = this._getControllerDir('ErrorController.js');
    if ( !dir ) {
        throw new Error('while handling error "' + e.message + '", could not find directory for Error Controller');
    }
    const method = this._getControllerMethod(dir, 'ErrorController.js', 'error');
    if ( !method ) {
        throw new Error('while handling error "' + e.message + '", could not find error action method in Error Controller');
    }
    req.error = message;
    method(req, resp).done((resp) => {
        httpResponse.writeHead(resp.returnCode, {'Content-Type': resp.contentType});
        httpResponse.write(resp.text);
        httpResponse.end();
    });
};

Server.prototype._getActionMethod = function(routeDesc) {
    // TODO can we find a more generic way to find the controller?
    const controllerFileName = this._getControllerFileName(routeDesc.controllerName);
    const controllerDir = this._getControllerDir(controllerFileName);

    if ( !controllerDir ) {
        throw new Error('dir for controller file ' + controllerFileName + ' not found');
    }

    const method = this._getControllerMethod(controllerDir, controllerFileName, routeDesc.actionName);

    if ( method === undefined ) {
        throw new Error('method not found: ' + routeDesc.actionName + ' in controller ' + routeDesc.controllerName);
    }
    return method;
};

Server.prototype._getControllerMethod = function(dir, fileName, actionName) {
    const controllerModule = require(dir + '/' + fileName);
    const controllerObject = controllerModule.create(this._config);
    const method = controllerObject[this._getActionMethodName(actionName)].bind(controllerObject);
    return method;
};
        
Server.prototype._getControllerDir = function(controllerFileName) {
    return deps._.find(this._config.web.server.controllerDirs, ( dir ) => {
        const controllerPath = dir + '/' + controllerFileName;
        try { // TODO this is ugly and brittle code, can we somehow test for the existence of a required file without using require()?
            require(controllerPath);
            return true;
        } catch (e) {
            if ( !e.message.match(/Cannot find module/) ) {
                console.error(e);
                throw e;
            }
            return undefined;
        }
    });
}
Server.prototype._getControllerFileName = function(controllerName) {
    return this._getControllerClassName(controllerName) + '.js';
};

Server.prototype._getControllerClassName = function(controllerName) {
    return deps._.capitalize(controllerName) + 'Controller';
};

Server.prototype._getActionMethodName = function(actionName) {
    return actionName + 'Action';
};
